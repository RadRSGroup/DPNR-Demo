"""
Growth Tracker Agent for DPNR Platform
Tracks psychological evolution and progress across life domains
Generated by TherapeuticAgentBuilder
Generated: 2025-07-21 21:15:00
"""
import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any, Union
from pydantic import BaseModel, Field, validator
from enum import Enum
import statistics
import json

from ...core.base_agent import BaseAgent, AgentMessage, AgentResponse, AgentCapability
from ...core.message_types import MessageType, PersonalityScore


class LifeDomain(str, Enum):
    """Core life domains for growth tracking"""
    RELATIONSHIPS = "relationships"
    CAREER_PURPOSE = "career_purpose"
    EMOTIONAL_WELLBEING = "emotional_wellbeing"
    SPIRITUAL_GROWTH = "spiritual_growth"
    PHYSICAL_HEALTH = "physical_health"
    CREATIVITY_EXPRESSION = "creativity_expression"
    PERSONAL_DEVELOPMENT = "personal_development"
    FAMILY_COMMUNITY = "family_community"


class GrowthMetricType(str, Enum):
    """Types of growth metrics"""
    EMOTIONAL_REGULATION = "emotional_regulation"
    SELF_AWARENESS = "self_awareness"
    RELATIONSHIP_QUALITY = "relationship_quality"
    PURPOSE_CLARITY = "purpose_clarity"
    STRESS_MANAGEMENT = "stress_management"
    AUTHENTICITY = "authenticity"
    RESILIENCE = "resilience"
    COMPASSION = "compassion"
    BOUNDARIES = "boundaries"
    SPIRITUAL_CONNECTION = "spiritual_connection"


class TrendDirection(str, Enum):
    """Growth trend directions"""
    IMPROVING = "improving"
    STABLE = "stable"
    DECLINING = "declining"
    BREAKTHROUGH = "breakthrough"
    INTEGRATION = "integration"


class GrowthEntry(BaseModel):
    """Individual growth measurement entry"""
    entry_id: str
    user_id: str
    domain: LifeDomain
    metric: GrowthMetricType
    value: float = Field(ge=0.0, le=10.0)  # 0-10 scale
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    context: Optional[str] = None
    session_id: Optional[str] = None
    confidence: float = Field(ge=0.0, le=1.0, default=0.8)
    notes: Optional[str] = None


class GrowthTrend(BaseModel):
    """Growth trend analysis"""
    domain: LifeDomain
    metric: GrowthMetricType
    trend_direction: TrendDirection
    trend_strength: float = Field(ge=0.0, le=1.0)  # How strong the trend is
    current_value: float
    previous_value: float
    change_rate: float  # Rate of change per week
    breakthrough_indicators: List[str] = Field(default_factory=list)
    integration_opportunities: List[str] = Field(default_factory=list)


class GrowthInsight(BaseModel):
    """Generated growth insights"""
    insight_type: str
    title: str
    description: str
    affected_domains: List[LifeDomain]
    actionable_steps: List[str]
    confidence: float = Field(ge=0.0, le=1.0)


class GrowthReport(BaseModel):
    """Comprehensive growth report"""
    user_id: str
    report_period: str  # "week", "month", "quarter"
    start_date: datetime
    end_date: datetime
    overall_growth_score: float = Field(ge=0.0, le=10.0)
    domain_scores: Dict[str, float]
    trends: List[GrowthTrend]
    insights: List[GrowthInsight]
    achievements: List[str]
    recommendations: List[str]
    next_focus_areas: List[str]


class GrowthTrackerAgent(BaseAgent):
    """
    Growth Tracker agent for monitoring psychological evolution
    Tracks progress across life domains and generates insights
    """
    
    def __init__(self):
        super().__init__(
            agent_id="growth-tracker-agent",
            name="Growth Tracker Agent", 
            version="1.0.0"
        )
        self.logger = logging.getLogger(__name__)
        self.growth_data: Dict[str, List[GrowthEntry]] = {}  # user_id -> entries
        
    async def initialize(self) -> bool:
        """Initialize Growth Tracker agent"""
        try:
            self.logger.info("Initializing Growth Tracker Agent")
            self._capabilities = [
                AgentCapability(
                    name="track_growth",
                    description="Record growth metric for user",
                    input_schema={"user_id": "string", "domain": "string", "metric": "string", "value": "number"},
                    output_schema={"recorded": "boolean", "trend": "string"}
                ),
                AgentCapability(
                    name="generate_report",
                    description="Generate comprehensive growth report",
                    input_schema={"user_id": "string", "period": "string"},
                    output_schema={"report": "object"}
                ),
                AgentCapability(
                    name="analyze_trends",
                    description="Analyze growth trends for user",
                    input_schema={"user_id": "string", "domains": "array"},
                    output_schema={"trends": "array"}
                ),
                AgentCapability(
                    name="get_insights",
                    description="Generate growth insights and recommendations",
                    input_schema={"user_id": "string", "focus_areas": "array"},
                    output_schema={"insights": "array"}
                )
            ]
            return True
        except Exception as e:
            self.logger.error(f"Failed to initialize: {e}")
            return False
    
    def get_capabilities(self) -> List[AgentCapability]:
        """Return agent capabilities"""
        return self._capabilities
    
    async def validate_input(self, data: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
        """Validate input data"""
        required_fields = {"action", "data"}
        if not all(field in data for field in required_fields):
            return False, f"Missing required fields: {required_fields}"
        
        action = data.get("action")
        valid_actions = ["track_growth", "generate_report", "analyze_trends", "get_insights"]
        if action not in valid_actions:
            return False, f"Unknown action: {action}. Valid actions: {valid_actions}"
            
        return True, None
    
    async def process(self, message: AgentMessage) -> AgentResponse:
        """Process growth tracking request"""
        start_time = datetime.utcnow()
        
        try:
            action = message.payload.get("action")
            data = message.payload.get("data", {})
            
            if action == "track_growth":
                result = await self.track_growth(
                    user_id=data.get("user_id"),
                    domain=data.get("domain"),
                    metric=data.get("metric"),
                    value=data.get("value"),
                    context=data.get("context"),
                    session_id=data.get("session_id")
                )
                
            elif action == "generate_report":
                result = await self.generate_growth_report(
                    user_id=data.get("user_id"),
                    period=data.get("period", "month"),
                    domains=data.get("domains")
                )
                
            elif action == "analyze_trends":
                result = await self.analyze_growth_trends(
                    user_id=data.get("user_id"),
                    domains=data.get("domains", []),
                    timeframe=data.get("timeframe", 30)
                )
                
            elif action == "get_insights":
                result = await self.generate_growth_insights(
                    user_id=data.get("user_id"),
                    focus_areas=data.get("focus_areas", [])
                )
                
            else:
                raise ValueError(f"Unknown action: {action}")
            
            confidence = self._calculate_confidence(result)
            
            return AgentResponse(
                success=True,
                data=result,
                processing_time=(datetime.utcnow() - start_time).total_seconds(),
                agent_id=self.agent_id,
                confidence=confidence
            )
            
        except Exception as e:
            self.logger.error(f"Processing failed: {e}")
            return AgentResponse(
                success=False,
                error=str(e),
                processing_time=(datetime.utcnow() - start_time).total_seconds(),
                agent_id=self.agent_id
            )
    
    async def track_growth(self, user_id: str, domain: str, metric: str, value: float,
                          context: Optional[str] = None, session_id: Optional[str] = None) -> Dict[str, Any]:
        """Record a growth measurement"""
        
        # Validate domain and metric
        try:
            life_domain = LifeDomain(domain)
            growth_metric = GrowthMetricType(metric)
        except ValueError as e:
            raise ValueError(f"Invalid domain or metric: {e}")
        
        # Validate value range
        if not (0.0 <= value <= 10.0):
            raise ValueError("Value must be between 0.0 and 10.0")
        
        # Create growth entry
        import uuid
        entry = GrowthEntry(
            entry_id=str(uuid.uuid4()),
            user_id=user_id,
            domain=life_domain,
            metric=growth_metric,
            value=value,
            context=context,
            session_id=session_id
        )
        
        # Store entry
        if user_id not in self.growth_data:
            self.growth_data[user_id] = []
        
        self.growth_data[user_id].append(entry)
        
        # Analyze trend
        trend = await self._analyze_metric_trend(user_id, life_domain, growth_metric)
        
        # Generate insights if significant change
        insights = []
        if len(self.growth_data[user_id]) > 1:
            insights = await self._check_breakthrough_indicators(user_id, entry)
        
        return {
            "recorded": True,
            "entry_id": entry.entry_id,
            "trend": trend,
            "current_value": value,
            "insights": insights,
            "total_entries": len(self.growth_data[user_id])
        }
    
    async def generate_growth_report(self, user_id: str, period: str = "month", 
                                   domains: Optional[List[str]] = None) -> Dict[str, Any]:
        """Generate comprehensive growth report"""
        
        if user_id not in self.growth_data or not self.growth_data[user_id]:
            return {"error": "No growth data found for user"}
        
        # Define time period
        end_date = datetime.utcnow()
        if period == "week":
            start_date = end_date - timedelta(weeks=1)
        elif period == "month":
            start_date = end_date - timedelta(days=30)
        elif period == "quarter":
            start_date = end_date - timedelta(days=90)
        else:
            start_date = end_date - timedelta(days=30)
        
        # Filter entries by period
        period_entries = [
            entry for entry in self.growth_data[user_id]
            if start_date <= entry.timestamp <= end_date
        ]
        
        if not period_entries:
            return {"error": f"No growth data found for {period} period"}
        
        # Filter by domains if specified
        if domains:
            try:
                domain_enums = [LifeDomain(d) for d in domains]
                period_entries = [e for e in period_entries if e.domain in domain_enums]
            except ValueError:
                return {"error": "Invalid domain specified"}
        
        # Calculate overall growth score
        overall_score = statistics.mean([entry.value for entry in period_entries])
        
        # Calculate domain scores
        domain_scores = {}
        for domain in LifeDomain:
            domain_entries = [e for e in period_entries if e.domain == domain]
            if domain_entries:
                domain_scores[domain.value] = statistics.mean([e.value for e in domain_entries])
        
        # Analyze trends
        trends = []
        for domain in LifeDomain:
            for metric in GrowthMetricType:
                trend = await self._analyze_metric_trend(user_id, domain, metric, 
                                                       timeframe_days=(end_date - start_date).days)
                if trend != "stable":
                    trend_obj = await self._create_trend_object(user_id, domain, metric, trend)
                    if trend_obj:
                        trends.append(trend_obj.dict())
        
        # Generate insights
        insights = await self.generate_growth_insights(user_id, domains or [])
        
        # Identify achievements
        achievements = await self._identify_achievements(user_id, period_entries)
        
        # Generate recommendations
        recommendations = await self._generate_recommendations(user_id, domain_scores, trends)
        
        # Identify next focus areas
        next_focus = await self._identify_focus_areas(user_id, domain_scores)
        
        report = GrowthReport(
            user_id=user_id,
            report_period=period,
            start_date=start_date,
            end_date=end_date,
            overall_growth_score=overall_score,
            domain_scores=domain_scores,
            trends=trends,
            insights=insights.get("insights", []),
            achievements=achievements,
            recommendations=recommendations,
            next_focus_areas=next_focus
        )
        
        return report.dict()
    
    async def analyze_growth_trends(self, user_id: str, domains: List[str] = None, 
                                  timeframe: int = 30) -> Dict[str, Any]:
        """Analyze growth trends for specific domains"""
        
        if user_id not in self.growth_data:
            return {"error": "No growth data found for user"}
        
        trends = []
        target_domains = domains or [d.value for d in LifeDomain]
        
        for domain_str in target_domains:
            try:
                domain = LifeDomain(domain_str)
                for metric in GrowthMetricType:
                    trend_direction = await self._analyze_metric_trend(
                        user_id, domain, metric, timeframe
                    )
                    
                    if trend_direction != "stable":
                        trend_obj = await self._create_trend_object(
                            user_id, domain, metric, trend_direction
                        )
                        if trend_obj:
                            trends.append(trend_obj.dict())
                            
            except ValueError:
                continue
        
        return {
            "trends": trends,
            "timeframe_days": timeframe,
            "analysis_date": datetime.utcnow().isoformat()
        }
    
    async def generate_growth_insights(self, user_id: str, focus_areas: List[str] = None) -> Dict[str, Any]:
        """Generate growth insights and recommendations"""
        
        if user_id not in self.growth_data or not self.growth_data[user_id]:
            return {"error": "No growth data found for user"}
        
        insights = []
        recent_entries = sorted(self.growth_data[user_id], key=lambda x: x.timestamp, reverse=True)[:20]
        
        # Pattern-based insights
        insights.extend(await self._generate_pattern_insights(user_id, recent_entries))
        
        # Cross-domain insights
        insights.extend(await self._generate_cross_domain_insights(user_id, recent_entries))
        
        # Breakthrough detection insights
        insights.extend(await self._generate_breakthrough_insights(user_id, recent_entries))
        
        # Integration opportunities
        insights.extend(await self._generate_integration_insights(user_id, recent_entries))
        
        return {
            "insights": [insight.dict() for insight in insights],
            "insight_count": len(insights),
            "generated_at": datetime.utcnow().isoformat()
        }
    
    async def _analyze_metric_trend(self, user_id: str, domain: LifeDomain, 
                                  metric: GrowthMetricType, timeframe_days: int = 30) -> str:
        """Analyze trend for specific metric"""
        
        if user_id not in self.growth_data:
            return "stable"
        
        cutoff_date = datetime.utcnow() - timedelta(days=timeframe_days)
        relevant_entries = [
            entry for entry in self.growth_data[user_id]
            if entry.domain == domain and entry.metric == metric and entry.timestamp >= cutoff_date
        ]
        
        if len(relevant_entries) < 2:
            return "stable"
        
        # Sort by timestamp
        relevant_entries.sort(key=lambda x: x.timestamp)
        
        # Calculate trend
        values = [entry.value for entry in relevant_entries]
        
        if len(values) < 3:
            change = values[-1] - values[0]
        else:
            # Use linear regression for better trend detection
            change = statistics.mean(values[-3:]) - statistics.mean(values[:3])
        
        if change > 0.5:
            return "improving"
        elif change < -0.5:
            return "declining"
        else:
            return "stable"
    
    async def _create_trend_object(self, user_id: str, domain: LifeDomain, 
                                 metric: GrowthMetricType, trend_direction: str) -> Optional[GrowthTrend]:
        """Create trend object with detailed analysis"""
        
        recent_entries = [
            entry for entry in self.growth_data[user_id]
            if entry.domain == domain and entry.metric == metric
        ]
        
        if len(recent_entries) < 2:
            return None
        
        recent_entries.sort(key=lambda x: x.timestamp, reverse=True)
        current_value = recent_entries[0].value
        previous_value = recent_entries[1].value if len(recent_entries) > 1 else current_value
        
        # Calculate change rate (per week)
        if len(recent_entries) >= 2:
            time_diff = (recent_entries[0].timestamp - recent_entries[1].timestamp).total_seconds()
            weeks_diff = time_diff / (7 * 24 * 3600)
            change_rate = (current_value - previous_value) / max(weeks_diff, 0.1)
        else:
            change_rate = 0.0
        
        # Determine trend strength
        trend_strength = min(abs(change_rate) / 2.0, 1.0)  # Scale to 0-1
        
        return GrowthTrend(
            domain=domain,
            metric=metric,
            trend_direction=TrendDirection(trend_direction),
            trend_strength=trend_strength,
            current_value=current_value,
            previous_value=previous_value,
            change_rate=change_rate,
            breakthrough_indicators=await self._detect_breakthrough_indicators(user_id, domain, metric),
            integration_opportunities=await self._identify_integration_opportunities(user_id, domain, metric)
        )
    
    async def _check_breakthrough_indicators(self, user_id: str, entry: GrowthEntry) -> List[str]:
        """Check for breakthrough indicators based on new entry"""
        indicators = []
        
        # Get recent entries for comparison
        user_entries = self.growth_data[user_id]
        recent_same_metric = [
            e for e in user_entries
            if e.domain == entry.domain and e.metric == entry.metric and e.entry_id != entry.entry_id
        ]
        
        if recent_same_metric:
            recent_same_metric.sort(key=lambda x: x.timestamp, reverse=True)
            previous_value = recent_same_metric[0].value
            
            # Significant improvement
            if entry.value - previous_value >= 2.0:
                indicators.append(f"Significant improvement in {entry.metric.value}: +{entry.value - previous_value:.1f}")
            
            # Consistency breakthrough
            if entry.value >= 7.0 and all(e.value >= 6.0 for e in recent_same_metric[:3]):
                indicators.append(f"Consistent high performance in {entry.metric.value}")
        
        # First-time high score
        if entry.value >= 8.0:
            high_scores = [e for e in user_entries if e.value >= 8.0 and e.entry_id != entry.entry_id]
            if len(high_scores) < 2:
                indicators.append(f"New personal high in {entry.domain.value}")
        
        return indicators
    
    async def _generate_pattern_insights(self, user_id: str, entries: List[GrowthEntry]) -> List[GrowthInsight]:
        """Generate insights based on growth patterns"""
        insights = []
        
        # Domain correlation insights
        domain_scores = {}
        for entry in entries:
            if entry.domain not in domain_scores:
                domain_scores[entry.domain] = []
            domain_scores[entry.domain].append(entry.value)
        
        # Find domains moving together
        for domain1 in domain_scores:
            for domain2 in domain_scores:
                if domain1 != domain2 and len(domain_scores[domain1]) >= 3 and len(domain_scores[domain2]) >= 3:
                    # Simple correlation check
                    trend1 = statistics.mean(domain_scores[domain1][-3:]) - statistics.mean(domain_scores[domain1][:3])
                    trend2 = statistics.mean(domain_scores[domain2][-3:]) - statistics.mean(domain_scores[domain2][:3])
                    
                    if abs(trend1) > 0.5 and abs(trend2) > 0.5 and (trend1 * trend2) > 0:
                        insights.append(GrowthInsight(
                            insight_type="pattern_correlation",
                            title=f"{domain1.value.title()} and {domain2.value.title()} Growing Together",
                            description=f"Your growth in {domain1.value} appears connected to progress in {domain2.value}",
                            affected_domains=[domain1, domain2],
                            actionable_steps=[
                                f"Continue nurturing both {domain1.value} and {domain2.value}",
                                "Look for ways these domains can mutually support each other"
                            ],
                            confidence=0.75
                        ))
                        break
        
        return insights[:2]  # Limit to top insights
    
    async def _generate_cross_domain_insights(self, user_id: str, entries: List[GrowthEntry]) -> List[GrowthInsight]:
        """Generate cross-domain insights"""
        insights = []
        
        # High-level patterns
        spiritual_entries = [e for e in entries if e.domain == LifeDomain.SPIRITUAL_GROWTH]
        relationship_entries = [e for e in entries if e.domain == LifeDomain.RELATIONSHIPS]
        
        if spiritual_entries and relationship_entries:
            spiritual_avg = statistics.mean([e.value for e in spiritual_entries])
            relationship_avg = statistics.mean([e.value for e in relationship_entries])
            
            if spiritual_avg > 7.0 and relationship_avg > 7.0:
                insights.append(GrowthInsight(
                    insight_type="integration_opportunity",
                    title="Spiritual-Relationship Integration",
                    description="Your spiritual growth and relationship quality are both flourishing - this creates opportunities for deeper connection",
                    affected_domains=[LifeDomain.SPIRITUAL_GROWTH, LifeDomain.RELATIONSHIPS],
                    actionable_steps=[
                        "Share your spiritual insights in close relationships",
                        "Practice compassion and presence in relationships",
                        "Explore how spiritual practices enhance intimacy"
                    ],
                    confidence=0.82
                ))
        
        return insights[:1]  # Limit insights
    
    async def _generate_breakthrough_insights(self, user_id: str, entries: List[GrowthEntry]) -> List[GrowthInsight]:
        """Generate breakthrough-related insights"""
        insights = []
        
        # Find metrics with recent significant improvements
        for metric in GrowthMetricType:
            metric_entries = [e for e in entries if e.metric == metric]
            if len(metric_entries) >= 2:
                metric_entries.sort(key=lambda x: x.timestamp, reverse=True)
                recent_avg = statistics.mean([e.value for e in metric_entries[:2]])
                older_avg = statistics.mean([e.value for e in metric_entries[-2:]])
                
                if recent_avg - older_avg >= 1.5:
                    insights.append(GrowthInsight(
                        insight_type="breakthrough",
                        title=f"Breakthrough in {metric.value.replace('_', ' ').title()}",
                        description=f"You've made significant progress in {metric.value}, indicating a potential breakthrough period",
                        affected_domains=[e.domain for e in metric_entries[:2]],
                        actionable_steps=[
                            f"Build on momentum in {metric.value}",
                            "Notice what specifically contributed to this improvement",
                            "Apply successful strategies to other areas"
                        ],
                        confidence=0.88
                    ))
        
        return insights[:1]
    
    async def _generate_integration_insights(self, user_id: str, entries: List[GrowthEntry]) -> List[GrowthInsight]:
        """Generate integration opportunity insights"""
        insights = []
        
        # Look for readiness for deeper work
        self_awareness_entries = [e for e in entries if e.metric == GrowthMetricType.SELF_AWARENESS]
        emotional_regulation_entries = [e for e in entries if e.metric == GrowthMetricType.EMOTIONAL_REGULATION]
        
        if self_awareness_entries and emotional_regulation_entries:
            awareness_avg = statistics.mean([e.value for e in self_awareness_entries])
            regulation_avg = statistics.mean([e.value for e in emotional_regulation_entries])
            
            if awareness_avg >= 7.0 and regulation_avg >= 6.5:
                insights.append(GrowthInsight(
                    insight_type="integration_readiness",
                    title="Ready for Deeper Integration Work",
                    description="Your self-awareness and emotional regulation suggest readiness for more advanced therapeutic work",
                    affected_domains=[LifeDomain.EMOTIONAL_WELLBEING, LifeDomain.PERSONAL_DEVELOPMENT],
                    actionable_steps=[
                        "Consider deeper shadow work or parts integration",
                        "Explore how your insights can guide others",
                        "Look into advanced therapeutic modalities"
                    ],
                    confidence=0.85
                ))
        
        return insights[:1]
    
    async def _identify_achievements(self, user_id: str, entries: List[GrowthEntry]) -> List[str]:
        """Identify achievements from growth data"""
        achievements = []
        
        # High scores
        high_scores = [e for e in entries if e.value >= 8.0]
        if high_scores:
            domains_with_highs = set([e.domain.value for e in high_scores])
            achievements.append(f"Achieved high scores (8+) in {len(domains_with_highs)} life domains")
        
        # Consistency
        metric_consistency = {}
        for entry in entries:
            if entry.metric not in metric_consistency:
                metric_consistency[entry.metric] = []
            metric_consistency[entry.metric].append(entry.value)
        
        for metric, values in metric_consistency.items():
            if len(values) >= 3 and all(v >= 6.0 for v in values):
                achievements.append(f"Maintained consistent growth in {metric.value.replace('_', ' ')}")
                break  # One consistency achievement is enough
        
        return achievements[:3]  # Limit achievements
    
    async def _generate_recommendations(self, user_id: str, domain_scores: Dict[str, float], 
                                      trends: List[Dict]) -> List[str]:
        """Generate personalized recommendations"""
        recommendations = []
        
        # Focus on lowest scoring domains
        if domain_scores:
            lowest_domain = min(domain_scores.keys(), key=lambda k: domain_scores[k])
            lowest_score = domain_scores[lowest_domain]
            
            if lowest_score < 6.0:
                recommendations.append(f"Focus attention on {lowest_domain.replace('_', ' ')} - this area has room for growth")
        
        # Leverage strong areas
        if domain_scores:
            highest_domain = max(domain_scores.keys(), key=lambda k: domain_scores[k])
            highest_score = domain_scores[highest_domain]
            
            if highest_score >= 7.5:
                recommendations.append(f"Use your strength in {highest_domain.replace('_', ' ')} to support growth in other areas")
        
        # Address declining trends
        declining_trends = [t for t in trends if t.get("trend_direction") == "declining"]
        if declining_trends:
            trend = declining_trends[0]
            recommendations.append(f"Pay attention to {trend['domain']} - early intervention can prevent further decline")
        
        return recommendations[:3]
    
    async def _identify_focus_areas(self, user_id: str, domain_scores: Dict[str, float]) -> List[str]:
        """Identify next focus areas for growth"""
        focus_areas = []
        
        if not domain_scores:
            return ["Establish consistent tracking across life domains"]
        
        # Areas needing attention (low scores)
        low_domains = [domain for domain, score in domain_scores.items() if score < 6.0]
        if low_domains:
            focus_areas.extend(low_domains[:2])
        
        # Growth edge areas (medium scores with potential)
        medium_domains = [domain for domain, score in domain_scores.items() if 6.0 <= score < 7.5]
        if medium_domains and len(focus_areas) < 2:
            focus_areas.extend(medium_domains[:2-len(focus_areas)])
        
        return focus_areas[:3]
    
    async def _detect_breakthrough_indicators(self, user_id: str, domain: LifeDomain, 
                                           metric: GrowthMetricType) -> List[str]:
        """Detect breakthrough indicators for specific metric"""
        indicators = []
        
        if user_id not in self.growth_data:
            return indicators
        
        relevant_entries = [
            e for e in self.growth_data[user_id]
            if e.domain == domain and e.metric == metric
        ]
        
        if len(relevant_entries) >= 3:
            recent_values = [e.value for e in sorted(relevant_entries, key=lambda x: x.timestamp)[-3:]]
            
            # Consistent improvement
            if all(recent_values[i] <= recent_values[i+1] for i in range(len(recent_values)-1)):
                indicators.append("Consistent upward trajectory")
            
            # High performance
            if statistics.mean(recent_values) >= 7.5:
                indicators.append("Sustained high performance")
        
        return indicators
    
    async def _identify_integration_opportunities(self, user_id: str, domain: LifeDomain, 
                                                metric: GrowthMetricType) -> List[str]:
        """Identify integration opportunities"""
        opportunities = []
        
        # Domain-specific opportunities
        if domain == LifeDomain.EMOTIONAL_WELLBEING and metric == GrowthMetricType.SELF_AWARENESS:
            opportunities.append("Ready for deeper parts work and shadow integration")
        elif domain == LifeDomain.RELATIONSHIPS and metric == GrowthMetricType.AUTHENTICITY:
            opportunities.append("Opportunity to model authenticity for others")
        elif domain == LifeDomain.SPIRITUAL_GROWTH and metric == GrowthMetricType.COMPASSION:
            opportunities.append("Ready to serve as guide or mentor for others")
        
        return opportunities
    
    def _calculate_confidence(self, result: Dict[str, Any]) -> float:
        """Calculate confidence score for result"""
        if "error" in result:
            return 0.3
        
        # Base confidence
        confidence = 0.8
        
        # Increase confidence with more data
        if "total_entries" in result and result["total_entries"] > 10:
            confidence += 0.1
        
        # Decrease confidence for limited data
        if "trends" in result and len(result["trends"]) < 2:
            confidence -= 0.1
        
        return max(0.3, min(1.0, confidence))
    
    async def health_check(self) -> Dict[str, Any]:
        """Health check for Growth Tracker agent"""
        return {
            "agent_id": self.agent_id,
            "status": "healthy",
            "total_users": len(self.growth_data),
            "total_entries": sum(len(entries) for entries in self.growth_data.values()),
            "capabilities": len(self._capabilities)
        }