"""
FastAPI endpoints for PaRDeS Reflection Agent
Generated by TherapeuticAgentBuilder
Generated: 2025-07-21 21:15:00
"""
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from pydantic import BaseModel, Field, validator
from typing import Dict, List, Optional, Any, Literal
from datetime import datetime
import logging

from .pardes_reflection_agent import (
    PaRDeSReflectionAgent, 
    ReflectionContext, 
    PaRDeSReflection,
    ReflectionLayer,
    DepthLevel
)
from ...core.base_agent import AgentMessage


router = APIRouter(prefix="/api/v1/pardes", tags=["pardes-reflection"])
logger = logging.getLogger(__name__)


class PaRDeSReflectRequest(BaseModel):
    """Request to generate PaRDeS reflection"""
    insight: str = Field(..., min_length=10, max_length=2000, description="The insight or experience to reflect upon")
    context: Dict[str, Any] = Field(default_factory=dict, description="User context for personalized reflection")
    depth_requested: Literal["surface", "moderate", "deep", "profound"] = Field(
        default="moderate", 
        description="Requested depth level for reflection"
    )
    user_id: str = Field(..., min_length=1, description="User identifier")
    
    @validator('insight')
    def validate_insight(cls, v):
        if not v.strip():
            raise ValueError("Insight cannot be empty")
        return v.strip()


class PaRDeSReflectResponse(BaseModel):
    """Response from PaRDeS reflection"""
    reflection_id: str
    layers: Dict[str, str]
    metaphors: List[str]
    integration_guidance: List[str]
    depth_level: float
    confidence: float
    processing_time: float


class DepthAssessmentRequest(BaseModel):
    """Request for depth readiness assessment"""
    user_id: str
    user_data: Dict[str, Any] = Field(default_factory=dict)


class DepthAssessmentResponse(BaseModel):
    """Response from depth assessment"""
    recommended_depth: str
    readiness_score: float
    explanation: str


class MetaphorRequest(BaseModel):
    """Request for metaphor generation"""
    insight: str = Field(..., min_length=5, max_length=1000)
    soul_archetype: Optional[str] = Field(default="seeker", description="User's soul archetype")
    user_id: str


class MetaphorResponse(BaseModel):
    """Response from metaphor generation"""
    metaphors: List[str]
    archetype_used: str


class HealthCheckResponse(BaseModel):
    """Health check response"""
    status: str
    agent_id: str
    capabilities: List[str]
    timestamp: datetime


# Dependency to get PaRDeS agent instance
async def get_pardes_agent() -> PaRDeSReflectionAgent:
    """Get or create PaRDeS agent instance"""
    try:
        agent = PaRDeSReflectionAgent()
        await agent.initialize()
        return agent
    except Exception as e:
        logger.error(f"Failed to initialize PaRDeS agent: {e}")
        raise HTTPException(status_code=500, detail="Agent initialization failed")


@router.post("/reflect", response_model=PaRDeSReflectResponse)
async def generate_pardes_reflection(
    request: PaRDeSReflectRequest,
    agent: PaRDeSReflectionAgent = Depends(get_pardes_agent)
) -> PaRDeSReflectResponse:
    """
    Generate multi-layer PaRDeS reflection from insight
    
    Creates four layers of interpretation:
    - Pshat: Literal meaning  
    - Remez: Emotional patterns
    - Drash: Reframed meaning
    - Sod: Soul truth (profound depth only)
    """
    try:
        start_time = datetime.utcnow()
        
        # Create agent message
        message = AgentMessage(
            id=f"pardes-{request.user_id}-{int(start_time.timestamp())}",
            source_agent="api",
            payload={
                "action": "generate_reflection",
                "data": {
                    "insight": request.insight,
                    "context": request.context,
                    "depth_requested": request.depth_requested
                }
            }
        )
        
        # Process with agent
        response = await agent.process(message)
        
        if not response.success:
            logger.error(f"PaRDeS reflection failed: {response.error}")
            raise HTTPException(status_code=500, detail=response.error)
        
        processing_time = (datetime.utcnow() - start_time).total_seconds()
        reflection_data = response.data
        
        return PaRDeSReflectResponse(
            reflection_id=reflection_data.get("reflection_id", "unknown"),
            layers=reflection_data.get("layers", {}),
            metaphors=reflection_data.get("metaphors", []),
            integration_guidance=reflection_data.get("integration_guidance", []),
            depth_level=reflection_data.get("depth_level", 0.5),
            confidence=reflection_data.get("confidence", response.confidence or 0.75),
            processing_time=processing_time
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error in PaRDeS reflection: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")


@router.post("/assess-depth", response_model=DepthAssessmentResponse)
async def assess_depth_readiness(
    request: DepthAssessmentRequest,
    agent: PaRDeSReflectionAgent = Depends(get_pardes_agent)
) -> DepthAssessmentResponse:
    """
    Assess user's readiness for different depth levels
    
    Evaluates factors like growth level, spiritual development,
    therapeutic history, and current challenges to recommend
    appropriate depth level.
    """
    try:
        # Create agent message
        message = AgentMessage(
            id=f"depth-{request.user_id}-{int(datetime.utcnow().timestamp())}",
            source_agent="api",
            payload={
                "action": "determine_readiness",
                "data": {
                    "user_data": request.user_data
                }
            }
        )
        
        # Process with agent
        response = await agent.process(message)
        
        if not response.success:
            logger.error(f"Depth assessment failed: {response.error}")
            raise HTTPException(status_code=500, detail=response.error)
        
        result_data = response.data
        recommended_depth = result_data.get("depth_level", "moderate")
        readiness_score = result_data.get("readiness", 0.5)
        
        # Generate explanation
        explanations = {
            "surface": "Current readiness suggests focusing on literal understanding and basic emotional awareness. Building foundation is recommended.",
            "moderate": "Ready for emotional pattern recognition and deeper self-awareness. Can explore personal growth themes safely.",
            "deep": "Prepared for perspective reframing and meaning-making. Can handle challenging insights with proper integration support.",
            "profound": "Ready for soul-level truths and mystical insights. Has strong foundation for transformational work."
        }
        
        return DepthAssessmentResponse(
            recommended_depth=recommended_depth,
            readiness_score=readiness_score,
            explanation=explanations.get(recommended_depth, "Assessment complete")
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error in depth assessment: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")


@router.post("/metaphors", response_model=MetaphorResponse)
async def generate_metaphors(
    request: MetaphorRequest,
    agent: PaRDeSReflectionAgent = Depends(get_pardes_agent)
) -> MetaphorResponse:
    """
    Generate metaphors for specific insight based on soul archetype
    
    Creates universal symbols and metaphors tailored to user's
    soul archetype (guide, healer, mystic, seeker, creator).
    """
    try:
        # Create agent message
        message = AgentMessage(
            id=f"metaphor-{request.user_id}-{int(datetime.utcnow().timestamp())}",
            source_agent="api", 
            payload={
                "action": "create_metaphors",
                "data": {
                    "insight": request.insight,
                    "soul_archetype": request.soul_archetype
                }
            }
        )
        
        # Process with agent
        response = await agent.process(message)
        
        if not response.success:
            logger.error(f"Metaphor generation failed: {response.error}")
            raise HTTPException(status_code=500, detail=response.error)
        
        result_data = response.data
        
        return MetaphorResponse(
            metaphors=result_data.get("metaphors", []),
            archetype_used=request.soul_archetype or "seeker"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error in metaphor generation: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")


@router.get("/depth-levels")
async def get_depth_levels() -> Dict[str, Any]:
    """
    Get available depth levels and their descriptions
    
    Returns information about the four PaRDeS layers and
    depth level requirements for safe practice.
    """
    return {
        "depth_levels": {
            "surface": {
                "name": "Pshat (Surface)",
                "description": "Literal meaning and basic acknowledgment",
                "layers_included": ["pshat"],
                "suitable_for": "New users, crisis situations, building foundation"
            },
            "moderate": {
                "name": "Pshat + Remez (Moderate)", 
                "description": "Literal meaning plus emotional patterns",
                "layers_included": ["pshat", "remez"],
                "suitable_for": "Regular users with some self-awareness"
            },
            "deep": {
                "name": "Pshat + Remez + Drash (Deep)",
                "description": "Includes reframed meaning and perspective shifts", 
                "layers_included": ["pshat", "remez", "drash"],
                "suitable_for": "Experienced users ready for growth challenges"
            },
            "profound": {
                "name": "All Four Layers (Profound)",
                "description": "Complete PaRDeS including soul truth (Sod)",
                "layers_included": ["pshat", "remez", "drash", "sod"], 
                "suitable_for": "Advanced users with strong spiritual foundation"
            }
        },
        "pardes_layers": {
            "pshat": "פשט - Literal/surface meaning",
            "remez": "רמז - Emotional patterns and hints", 
            "drash": "דרש - Reframed meaning and interpretation",
            "sod": "סוד - Soul truth and mystical essence"
        },
        "safety_guidelines": [
            "Start with surface level and progress gradually",
            "Deep and profound levels require therapeutic support",
            "Crisis situations should use surface level only",
            "Integration time needed between profound sessions"
        ]
    }


@router.get("/health", response_model=HealthCheckResponse)
async def health_check(
    agent: PaRDeSReflectionAgent = Depends(get_pardes_agent)
) -> HealthCheckResponse:
    """Check PaRDeS agent health and capabilities"""
    try:
        capabilities = [cap.name for cap in agent.get_capabilities()]
        
        return HealthCheckResponse(
            status="healthy",
            agent_id=agent.agent_id,
            capabilities=capabilities,
            timestamp=datetime.utcnow()
        )
        
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        raise HTTPException(status_code=503, detail="Agent health check failed")


# Integration endpoints for other DPNR systems
@router.post("/integrate/growth-tracker")
async def integrate_with_growth_tracker(
    user_id: str,
    growth_metrics: Dict[str, float],
    agent: PaRDeSReflectionAgent = Depends(get_pardes_agent)
) -> Dict[str, Any]:
    """
    Integration endpoint for Growth Tracker system
    
    Receives growth metrics and generates reflection on progress
    """
    try:
        # Convert growth metrics to insight
        growth_insights = []
        for domain, value in growth_metrics.items():
            if value >= 7.0:
                growth_insights.append(f"breakthrough in {domain}")
            elif value >= 5.0:
                growth_insights.append(f"steady progress in {domain}")
            else:
                growth_insights.append(f"challenge in {domain}")
        
        insight = f"Recent growth shows: {', '.join(growth_insights)}"
        
        # Determine appropriate depth based on highest growth metric
        max_growth = max(growth_metrics.values()) if growth_metrics else 5.0
        if max_growth >= 8.0:
            depth = "deep"
        elif max_growth >= 6.0:
            depth = "moderate" 
        else:
            depth = "surface"
        
        # Generate reflection
        request = PaRDeSReflectRequest(
            insight=insight,
            context={"growth_metrics": growth_metrics},
            depth_requested=depth,
            user_id=user_id
        )
        
        reflection = await generate_pardes_reflection(request, agent)
        
        return {
            "integration_type": "growth_tracker",
            "reflection": reflection.dict(),
            "growth_summary": {
                "highest_domain": max(growth_metrics.items(), key=lambda x: x[1])[0],
                "overall_trend": "improving" if max_growth > 6.0 else "developing"
            }
        }
        
    except Exception as e:
        logger.error(f"Growth Tracker integration failed: {e}")
        raise HTTPException(status_code=500, detail="Integration failed")


@router.post("/integrate/digital-twin")  
async def integrate_with_digital_twin(
    user_id: str,
    twin_data: Dict[str, Any],
    insight: str,
    agent: PaRDeSReflectionAgent = Depends(get_pardes_agent)
) -> Dict[str, Any]:
    """
    Integration endpoint for Digital Twin system
    
    Uses twin archetype to personalize PaRDeS reflection
    """
    try:
        # Extract relevant twin data
        context = {
            "soul_archetype": twin_data.get("archetype", "seeker"),
            "growth_level": twin_data.get("integration_score", 5.0) * 10,
            "spiritual_readiness": twin_data.get("wisdom_level", 0.5) * 10
        }
        
        # Determine depth based on twin development
        integration_score = twin_data.get("integration_score", 0.5)
        if integration_score >= 0.8:
            depth = "profound"
        elif integration_score >= 0.6:
            depth = "deep"
        elif integration_score >= 0.4:
            depth = "moderate"
        else:
            depth = "surface"
        
        # Generate reflection
        request = PaRDeSReflectRequest(
            insight=insight,
            context=context,
            depth_requested=depth,
            user_id=user_id
        )
        
        reflection = await generate_pardes_reflection(request, agent)
        
        return {
            "integration_type": "digital_twin",
            "reflection": reflection.dict(),
            "twin_context": {
                "archetype": context["soul_archetype"],
                "development_level": integration_score,
                "recommended_depth": depth
            }
        }
        
    except Exception as e:
        logger.error(f"Digital Twin integration failed: {e}")
        raise HTTPException(status_code=500, detail="Integration failed")