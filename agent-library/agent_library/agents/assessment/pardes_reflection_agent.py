"""
PaRDeS Reflection Agent for DPNR Platform
Four-layer Kabbalistic interpretive framework
Generated by TherapeuticAgentBuilder
Generated: 2025-07-21 21:15:00
"""
import asyncio
import logging
from datetime import datetime, timezone
from typing import Dict, List, Optional, Tuple, Any
from pydantic import BaseModel, Field, validator
from enum import Enum
import uuid
import json
import os
try:
    import openai
    from openai import AsyncOpenAI
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    openai = None
    AsyncOpenAI = None

from ...core.base_agent import BaseAgent, AgentMessage, AgentResponse, AgentCapability
from ...core.message_types import MessageType, PersonalityScore


class ReflectionLayer(str, Enum):
    """Four layers of PaRDeS interpretation"""
    PSHAT = "pshat"      # Literal insight
    REMEZ = "remez"      # Emotional pattern
    DRASH = "drash"      # Reframed meaning
    SOD = "sod"          # Soul truth


class DepthLevel(str, Enum):
    """User readiness for depth levels"""
    SURFACE = "surface"      # Pshat only
    MODERATE = "moderate"    # Pshat + Remez
    DEEP = "deep"           # Pshat + Remez + Drash
    PROFOUND = "profound"   # All four layers


class PaRDeSReflection(BaseModel):
    """Complete PaRDeS reflection output"""
    reflection_id: str
    user_id: str
    original_insight: str
    layers: Dict[str, str]  # layer -> reflection
    metaphors: List[str]
    integration_guidance: List[str]
    depth_level: float = Field(ge=0.0, le=1.0)
    confidence: float = Field(ge=0.0, le=1.0)
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class ReflectionContext(BaseModel):
    """Context for generating reflection"""
    soul_archetype: Optional[str] = None
    growth_level: Optional[float] = None
    therapeutic_history: Optional[List[str]] = None
    current_challenges: Optional[List[str]] = None
    spiritual_readiness: Optional[float] = None


class PaRDeSReflectionAgent(BaseAgent):
    """
    PaRDeS Reflection Agent implementing Kabbalistic four-layer interpretation
    Pshat (literal) → Remez (emotional) → Drash (reframed) → Sod (soul truth)
    """
    
    def __init__(self):
        super().__init__(
            agent_id="pardes-reflection-agent",
            name="PaRDeS Reflection Agent",
            version="1.0.0"
        )
        self.logger = logging.getLogger(__name__)
        self.metaphor_library = self._load_metaphor_library()
        
        # Initialize OpenAI client for AI-powered layer generation
        api_key = os.getenv('OPENAI_API_KEY')
        if api_key and OPENAI_AVAILABLE:
            self.openai_client = AsyncOpenAI(api_key=api_key)
            self.ai_enabled = True
            self.logger.info("OpenAI client initialized for enhanced PaRDeS generation")
        else:
            self.openai_client = None
            self.ai_enabled = False
            if not OPENAI_AVAILABLE:
                self.logger.warning("OpenAI library not available - using rule-based generation")
            else:
                self.logger.warning("No OpenAI API key found - falling back to rule-based generation")
        
    async def initialize(self) -> bool:
        """Initialize PaRDeS reflection agent"""
        try:
            self.logger.info("Initializing PaRDeS Reflection Agent")
            self._capabilities = [
                AgentCapability(
                    name="generate_reflection",
                    description="Generate multi-layer PaRDeS reflection",
                    input_schema={"insight": "string", "context": "object", "depth": "string"},
                    output_schema={"layers": "object", "metaphors": "array"}
                ),
                AgentCapability(
                    name="determine_readiness",
                    description="Assess user readiness for depth levels",
                    input_schema={"user_data": "object"},
                    output_schema={"depth_level": "string", "readiness": "number"}
                ),
                AgentCapability(
                    name="create_metaphors",
                    description="Generate metaphors for insights",
                    input_schema={"insight": "string", "archetype": "string"},
                    output_schema={"metaphors": "array"}
                )
            ]
            return True
        except Exception as e:
            self.logger.error(f"Failed to initialize: {e}")
            return False
    
    def get_capabilities(self) -> List[AgentCapability]:
        """Return agent capabilities"""
        return self._capabilities
    
    async def validate_input(self, data: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
        """Validate input data"""
        required_fields = {"action", "data"}
        if not all(field in data for field in required_fields):
            return False, f"Missing required fields: {required_fields}"
        
        action = data.get("action")
        valid_actions = ["generate_reflection", "determine_readiness", "create_metaphors"]
        if action not in valid_actions:
            return False, f"Unknown action: {action}. Valid: {valid_actions}"
            
        return True, None
    
    async def process(self, message: AgentMessage) -> AgentResponse:
        """Process PaRDeS reflection request"""
        start_time = datetime.now(timezone.utc)
        
        try:
            action = message.payload.get("action")
            data = message.payload.get("data", {})
            
            if action == "generate_reflection":
                reflection = await self.generate_reflection(
                    data.get("insight", ""),
                    ReflectionContext(**data.get("context", {})),
                    data.get("depth_requested", "moderate")
                )
                result = reflection.dict()
                
            elif action == "determine_readiness":
                depth_level, readiness = await self.determine_user_readiness(
                    data.get("user_data", {})
                )
                result = {"depth_level": depth_level, "readiness": readiness}
                
            elif action == "create_metaphors":
                metaphors = await self.create_metaphors(
                    data.get("insight", ""),
                    data.get("soul_archetype", "seeker")
                )
                result = {"metaphors": metaphors}
                
            else:
                raise ValueError(f"Unknown action: {action}")
            
            # Calculate processing confidence based on action success
            processing_confidence = 0.85
            if action == "generate_reflection" and isinstance(result, dict) and result.get('confidence'):
                processing_confidence = min(0.9, max(0.6, result['confidence'] * 0.95))
            
            return AgentResponse(
                success=True,
                data=result,
                processing_time=(datetime.now(timezone.utc) - start_time).total_seconds(),
                agent_id=self.agent_id,
                confidence=processing_confidence
            )
            
        except Exception as e:
            self.logger.error(f"Processing failed: {e}")
            return AgentResponse(
                success=False,
                error=str(e),
                processing_time=(datetime.now(timezone.utc) - start_time).total_seconds(),
                agent_id=self.agent_id
            )
    
    async def generate_reflection(self, insight: str, context: ReflectionContext, 
                                depth_requested: str) -> PaRDeSReflection:
        """Generate multi-layer PaRDeS reflection"""
        
        reflection_id = str(uuid.uuid4())[:8]
        layers = {}
        
        # PSHAT - Literal meaning
        layers["pshat"] = await self._generate_pshat(insight)
        
        # REMEZ - Emotional patterns (if depth allows)
        if depth_requested in ["moderate", "deep", "profound"]:
            layers["remez"] = await self._generate_remez(insight, context)
        
        # DRASH - Reframed meaning (if depth allows)  
        if depth_requested in ["deep", "profound"]:
            layers["drash"] = await self._generate_drash(insight, context)
        
        # SOD - Soul truth (only for profound depth)
        if depth_requested == "profound":
            layers["sod"] = await self._generate_sod(insight, context)
        
        # Validate therapeutic safety before proceeding
        safety_check = await self._validate_therapeutic_safety(insight, layers, context)
        if not safety_check['safe']:
            self.logger.warning(f"Safety concerns detected: {safety_check['reason']}")
            layers = await self._apply_safety_modifications(layers, safety_check)
        
        # Generate metaphors
        metaphors = await self.create_metaphors(insight, context.soul_archetype or "seeker")
        
        # Create integration guidance
        integration_guidance = await self._create_integration_guidance(layers, context)
        
        # Calculate dynamic confidence based on layer quality and context
        confidence = await self._calculate_reflection_confidence(layers, context, depth_requested)
        
        return PaRDeSReflection(
            reflection_id=reflection_id,
            user_id=getattr(context, 'user_id', 'unknown') or "unknown",
            original_insight=insight,
            layers=layers,
            metaphors=metaphors,
            integration_guidance=integration_guidance,
            depth_level=self._calculate_depth_level(depth_requested),
            confidence=confidence
        )
    
    async def _generate_pshat(self, insight: str) -> str:
        """Generate literal interpretation (Pshat layer)"""
        
        try:
            # Use AI to generate contextual literal interpretation
            prompt = f"""
            Generate a clear, literal interpretation of this insight using the Pshat (literal/surface) level of understanding.
            
            Insight: "{insight}"
            
            Guidelines:
            - Acknowledge exactly what happened without interpretation
            - Use simple, direct language
            - Stay at surface level - no deeper meaning
            - Validate the person's experience as stated
            - 1-2 sentences maximum
            
            Example: "You felt angry when your colleague interrupted you during the meeting."
            """
            
            response = await self._make_ai_request(prompt, max_tokens=100)
            return response.strip()
            
        except Exception as e:
            self.logger.error(f"Error generating Pshat layer: {e}")
            # Fallback to improved template
            if any(word in insight.lower() for word in ["felt", "feeling", "emotion"]):
                return f"You experienced: {insight.strip('.')}." 
            elif any(word in insight.lower() for word in ["thought", "realized", "understood"]):
                return f"You had the realization: {insight.strip('.')}."  
            else:
                return f"What happened was: {insight.strip('.')}."
    
    async def _generate_remez(self, insight: str, context: ReflectionContext) -> str:
        """Generate emotional pattern interpretation (Remez layer)"""
        
        try:
            # Build context for AI analysis
            context_info = []
            if hasattr(context, 'growth_level') and context.growth_level:
                context_info.append(f"Growth level: {context.growth_level}/10")
            if hasattr(context, 'soul_archetype') and context.soul_archetype:
                context_info.append(f"Soul archetype: {context.soul_archetype}")
            if hasattr(context, 'session_history') and context.session_history:
                context_info.append(f"Recent patterns: {context.session_history[-2:]}")
                
            context_str = "; ".join(context_info) if context_info else "No additional context"
            
            prompt = f"""
            Generate a Remez (emotional pattern) interpretation of this insight. Remez reveals the emotional undercurrents and recurring patterns.
            
            Insight: "{insight}"
            Context: {context_str}
            
            Guidelines:
            - Identify the emotional pattern beneath the surface
            - Connect to recurring themes in relationships or self-concept
            - Use therapeutic insight about emotional development
            - Avoid surface-level advice - focus on pattern recognition
            - Connect to deeper emotional needs or wounds
            - 2-3 sentences maximum
            
            Example: "This frustration reveals a pattern of feeling unheard in relationships, particularly when your authentic self seeks expression. This pattern may connect to early experiences where your voice wasn't valued or acknowledged."
            """
            
            response = await self._make_ai_request(prompt, max_tokens=150)
            return response.strip()
            
        except Exception as e:
            self.logger.error(f"Error generating Remez layer: {e}")
            # Intelligent fallback based on emotional analysis
            return await self._analyze_emotional_pattern_fallback(insight, context)
    
    async def _generate_drash(self, insight: str, context: ReflectionContext) -> str:
        """Generate reframed meaning interpretation (Drash layer)"""
        
        try:
            # Build sophisticated context for reframing
            growth_level = getattr(context, 'growth_level', 5.0) or 5.0
            soul_archetype = getattr(context, 'soul_archetype', 'seeker')
            
            # Determine reframing depth based on growth level
            if growth_level < 4.0:
                depth_guidance = "Focus on basic growth invitation and learning opportunity"
            elif growth_level < 7.0:
                depth_guidance = "Emphasize wisdom teaching and inner development"
            else:
                depth_guidance = "Reveal soul-level orchestration and consciousness integration"
                
            prompt = f"""
            Generate a Drash (reframed meaning) interpretation that transforms this insight into wisdom. Drash reveals the deeper meaning and spiritual purpose.
            
            Insight: "{insight}"
            Growth Level: {growth_level}/10 
            Soul Archetype: {soul_archetype}
            Reframing Depth: {depth_guidance}
            
            Guidelines:
            - Reframe challenge as growth opportunity or spiritual teaching
            - Show how apparent difficulty serves soul development
            - Connect to the person's unique growth journey
            - Reveal the hidden gift or wisdom in the experience
            - Use language appropriate to their spiritual development level
            - Avoid platitudes - make it personally meaningful
            - 2-3 sentences maximum
            
            Example: "What appeared as rejection from your colleague is actually your soul's way of redirecting you toward people who truly value your gifts. This experience is teaching you to trust your inner knowing rather than seeking external validation."
            """
            
            response = await self._make_ai_request(prompt, max_tokens=180)
            return response.strip()
            
        except Exception as e:
            self.logger.error(f"Error generating Drash layer: {e}")
            # Intelligent fallback based on growth level
            return await self._generate_drash_fallback(insight, context)
    
    async def _generate_sod(self, insight: str, context: ReflectionContext) -> str:
        """Generate soul truth interpretation (Sod layer)"""
        
        try:
            archetype = getattr(context, 'soul_archetype', 'seeker') or "seeker"
            growth_level = getattr(context, 'growth_level', 5.0) or 5.0
            
            prompt = f"""
            Generate a Sod (soul truth) interpretation that reveals the deepest mystical truth of this insight. Sod is the most profound level, revealing eternal wisdom.
            
            Insight: "{insight}"
            Soul Archetype: {archetype}
            Growth Level: {growth_level}/10
            
            Guidelines:
            - Reveal the eternal, universal truth within this experience
            - Connect to timeless spiritual principles and cosmic perspective
            - Show how this serves the soul's evolution and divine purpose
            - Use language appropriate to the archetype ({archetype})
            - Transcend personal drama to reveal universal patterns
            - Touch on themes of oneness, divine love, and sacred purpose
            - 2-4 sentences maximum
            
            Archetype-specific guidance:
            - Guide: Focus on serving others through wisdom gained
            - Healer: Emphasize transforming wounds into medicine
            - Creator: Show how experiences become divine art/beauty
            - Mystic: Reveal dissolution of separation and unity consciousness
            - Seeker: Emphasize that what's sought is already within
            
            Example: "At the soul level, this moment of rejection is the universe's way of redirecting you toward your true spiritual family. Your soul orchestrated this experience to free you from seeking love outside yourself, awakening you to the infinite love that you are."
            """
            
            response = await self._make_ai_request(prompt, max_tokens=200)
            return response.strip()
            
        except Exception as e:
            self.logger.error(f"Error generating Sod layer: {e}")
            # Intelligent fallback based on archetype
            return await self._generate_sod_fallback(insight, context)
    
    async def create_metaphors(self, insight: str, soul_archetype: Optional[str]) -> List[str]:
        """Generate universal metaphors for insight"""
        
        archetype = soul_archetype or "seeker"
        metaphor_sets = self.metaphor_library.get(archetype, self.metaphor_library["universal"])
        
        # Select appropriate metaphors based on insight content
        insight_lower = insight.lower()
        selected_metaphors = []
        
        if any(word in insight_lower for word in ["change", "transform", "grow"]):
            selected_metaphors.extend(metaphor_sets["transformation"][:2])
        
        if any(word in insight_lower for word in ["challenge", "difficult", "struggle"]):
            selected_metaphors.extend(metaphor_sets["challenge"][:2])
            
        if any(word in insight_lower for word in ["connection", "love", "relationship"]):
            selected_metaphors.extend(metaphor_sets["connection"][:2])
        
        # Ensure we have at least 2 metaphors
        if len(selected_metaphors) < 2:
            selected_metaphors.extend(metaphor_sets["universal"][:2])
        
        return selected_metaphors[:3]  # Max 3 metaphors
    
    async def _make_ai_request(self, prompt: str, max_tokens: int = 150) -> str:
        """Make AI request with fallback handling"""
        if not self.ai_enabled or not self.openai_client:
            raise Exception("OpenAI client not available")
            
        try:
            response = await self.openai_client.chat.completions.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=max_tokens,
                temperature=0.7
            )
            
            return response.choices[0].message.content.strip()
            
        except Exception as e:
            self.logger.error(f"OpenAI API error: {e}")
            raise
    
    async def _analyze_emotional_pattern_fallback(self, insight: str, context: ReflectionContext) -> str:
        """Intelligent fallback for Remez layer when AI fails"""
        
        # Enhanced emotional pattern analysis
        emotion_keywords = {
            "anger": ["angry", "frustrated", "irritated", "rage", "mad", "furious"],
            "fear": ["scared", "anxious", "worried", "afraid", "terrified", "nervous"],
            "sadness": ["sad", "hurt", "disappointed", "grief", "devastated", "heartbroken"],
            "joy": ["happy", "excited", "fulfilled", "content", "elated", "thrilled"],
            "shame": ["ashamed", "embarrassed", "guilty", "unworthy", "humiliated"],
            "love": ["loved", "connected", "appreciated", "valued", "cherished", "adored"]
        }
        
        insight_lower = insight.lower()
        detected_emotions = []
        
        for emotion, keywords in emotion_keywords.items():
            if any(keyword in insight_lower for keyword in keywords):
                detected_emotions.append(emotion)
        
        if detected_emotions:
            primary_emotion = detected_emotions[0]
            patterns = {
                "anger": "This anger hints at a deeper pattern of feeling unheard or powerless, possibly connecting to times when your boundaries were crossed or your voice dismissed.",
                "fear": "This fear reveals an underlying pattern of uncertainty about safety or belonging, often rooted in early experiences of unpredictability or rejection.",
                "sadness": "This sadness points to a pattern of loss or disconnection, suggesting unmet needs for understanding, acceptance, or genuine intimacy.",
                "joy": "This joy reflects a pattern of alignment with your authentic self, indicating moments when you feel truly seen and valued for who you are.",
                "shame": "This shame indicates a pattern of self-judgment, often stemming from messages received about not being 'enough' in some fundamental way.",
                "love": "This love reveals a pattern of openness and connection, showing your capacity for deep bonding and authentic relationship."
            }
            return patterns.get(primary_emotion, "This emotional response hints at deeper patterns in how you relate to yourself and others.")
        
        # Context-based fallback
        growth_level = getattr(context, 'growth_level', 5.0) or 5.0
        if growth_level > 7.0:
            return "This experience reveals recurring emotional patterns that point to your soul's invitation for deeper healing and integration."
        else:
            return "This situation connects to emotional patterns in how you navigate relationships and respond to life's challenges."
            
    async def _generate_drash_fallback(self, insight: str, context: ReflectionContext) -> str:
        """Intelligent fallback for Drash layer when AI fails"""
        
        growth_level = getattr(context, 'growth_level', 5.0) or 5.0
        archetype = getattr(context, 'soul_archetype', 'seeker')
        
        if growth_level < 4.0:
            return "This experience can be reframed as an invitation to grow. What felt challenging is actually your soul's way of showing you where healing and development are needed."
        elif growth_level < 7.0:
            return "This situation reveals itself as a teacher when viewed from a higher perspective. What appeared as difficulty is actually your inner wisdom creating conditions for your next level of development."
        else:
            # Archetype-specific advanced reframing
            archetype_reframes = {
                "guide": "From your soul's perspective as a guide, this experience is teaching you wisdom that you'll later share with others who face similar challenges.",
                "healer": "This challenging experience is deepening your capacity to heal others by first healing this aspect within yourself.",
                "creator": "Your soul is using this experience as raw material for the beautiful transformation you're creating in your life.",
                "mystic": "This situation is dissolving illusions and revealing deeper truths about the nature of reality and your spiritual journey.",
                "seeker": "What felt like a setback is actually your soul orchestrating the perfect conditions for your next breakthrough."
            }
            return archetype_reframes.get(archetype, archetype_reframes["seeker"])
    
    async def _generate_sod_fallback(self, insight: str, context: ReflectionContext) -> str:
        """Intelligent fallback for Sod layer when AI fails"""
        
        archetype = getattr(context, 'soul_archetype', 'seeker') or "seeker"
        
        sod_templates = {
            "guide": "At the deepest level, this experience reveals that you are a conduit for divine wisdom. Every challenge you face is the universe speaking through you, using your life as a sacred text to teach others about love's triumph over fear.",
            "healer": "The soul truth here is that your wounds are not obstacles but sacred doorways. What you've experienced is part of your soul's agreement to transform pain into medicine, becoming a living bridge between suffering and wholeness.",
            "creator": "In the mystical dimension, this reveals that you are not separate from the creative force of the universe. Your experiences are the raw materials from which divine beauty emerges, each moment a brushstroke in your becoming.",
            "mystic": "At the level of ultimate truth, this experience dissolves the illusion of separation entirely. What seemed personal reveals itself as the universal story of consciousness awakening to itself through your incarnation.",
            "seeker": "The deepest truth is that what you seek is already within you. This experience is not happening TO you but AS you - your soul creating perfect circumstances to remember your inherent wholeness."
        }
        
        return sod_templates.get(archetype, sod_templates["seeker"])
    
    async def determine_user_readiness(self, user_data: Dict[str, Any]) -> Tuple[str, float]:
        """Assess user readiness for depth levels with safety protocols"""
        
        # First check for crisis indicators - safety first
        current_challenges = user_data.get("current_challenges", [])
        crisis_indicators = ["crisis", "emergency", "suicidal", "breakdown", "self-harm", "trauma"]
        is_in_crisis = any(indicator in str(current_challenges).lower() for indicator in crisis_indicators)
        
        # Safety protocol: Crisis users get surface level only
        if is_in_crisis:
            self.logger.warning(f"Crisis indicators detected, restricting to surface level: {current_challenges}")
            return DepthLevel.SURFACE.value, 0.1  # Very low readiness score
        
        # Calculate readiness score for non-crisis users
        readiness_score = 0.0
        
        # Growth level factor (30% of total score)
        growth_level = user_data.get("growth_level", 5.0)
        readiness_score += min(growth_level / 10.0, 0.3)
        
        # Spiritual development factor (30% of total score)
        spiritual_readiness = user_data.get("spiritual_readiness", 5.0)
        readiness_score += min(spiritual_readiness / 10.0, 0.3)
        
        # Therapeutic history factor (20% of total score)
        therapy_sessions = len(user_data.get("therapeutic_history", []))
        readiness_score += min(therapy_sessions / 20.0, 0.2)
        
        # Self-awareness bonus (20% of total score)
        self_awareness = user_data.get("self_awareness_level", 5.0)
        if self_awareness > 7.0:
            readiness_score += 0.2
        elif self_awareness > 5.0:
            readiness_score += 0.1
        
        # Stability check - ensure emotional stability for deeper work
        emotional_stability = user_data.get("emotional_stability", 5.0)
        if emotional_stability < 4.0 and readiness_score > 0.6:
            readiness_score = min(readiness_score, 0.6)  # Cap at moderate for unstable users
            self.logger.info(f"Emotional stability {emotional_stability} - capping depth level")
        
        # Determine depth level with clear thresholds
        if readiness_score < 0.35:  # Very low readiness
            return DepthLevel.SURFACE.value, readiness_score
        elif readiness_score < 0.60:  # Moderate readiness
            return DepthLevel.MODERATE.value, readiness_score
        elif readiness_score < 0.80:  # High readiness
            return DepthLevel.DEEP.value, readiness_score
        else:  # Very high readiness (0.80+)
            return DepthLevel.PROFOUND.value, readiness_score
    
    async def _create_integration_guidance(self, layers: Dict[str, str], 
                                         context: ReflectionContext) -> List[str]:
        """Create integration guidance based on layers"""
        
        guidance = []
        
        # Basic integration for all levels
        guidance.append("Sit quietly with each layer of meaning, allowing them to settle into your awareness")
        
        if "remez" in layers:
            guidance.append("Notice how the emotional patterns show up in your daily life relationships")
        
        if "drash" in layers:
            guidance.append("Journal about how this reframed perspective changes your relationship to the experience")
        
        if "sod" in layers:
            guidance.append("Allow the soul truth to guide your actions from a place of deeper knowing")
            guidance.append("Share this wisdom with others when appropriate, as your truth serves collective healing")
        
        return guidance
    
    def _calculate_depth_level(self, depth_requested: str) -> float:
        """Calculate numeric depth level"""
        depth_map = {
            "surface": 0.25,
            "moderate": 0.5,
            "deep": 0.75,
            "profound": 1.0
        }
        return depth_map.get(depth_requested, 0.5)
    
    def _load_metaphor_library(self) -> Dict[str, Dict[str, List[str]]]:
        """Load metaphor library organized by archetype and theme"""
        
        return {
            "universal": {
                "transformation": [
                    "Like a caterpillar dissolving into butterfly essence",
                    "Like water becoming steam, changing form but not essence",
                    "Like a seed breaking open to become a mighty oak"
                ],
                "challenge": [
                    "Like a diamond formed under immense pressure",
                    "Like a river carving its path through ancient stone", 
                    "Like dawn breaking through the darkest hour"
                ],
                "connection": [
                    "Like separate notes finding their harmony",
                    "Like two flames becoming one greater light",
                    "Like roots of different trees intertwining underground"
                ]
            },
            
            "guide": {
                "transformation": [
                    "Like a lighthouse steady in the storm, your essence remains constant while guiding others",
                    "Like a mountain that provides different paths to the same summit"
                ],
                "challenge": [
                    "Like a wise elder who has walked through fire and emerged with medicine",
                    "Like a compass that points true north regardless of magnetic interference"
                ],
                "connection": [
                    "Like a bridge spanning two worlds, allowing safe passage between them",
                    "Like a translator speaking the language of hearts"
                ]
            },
            
            "healer": {
                "transformation": [
                    "Like medicine created from poison, your wounds become your healing gift",
                    "Like a phoenix whose ashes nourish new life"
                ],
                "challenge": [
                    "Like a surgeon's knife that cuts to heal",
                    "Like rain that falls to nourish the earth"
                ],
                "connection": [
                    "Like a heart that beats in rhythm with all hearts",
                    "Like hands that remember how to mend what was broken"
                ]
            },
            
            "mystic": {
                "transformation": [
                    "Like the ocean appearing as separate waves while remaining one body of water",
                    "Like a mirror realizing it is both the reflection and the reflected"
                ],
                "challenge": [
                    "Like consciousness exploring itself through the dance of apparent opposites",
                    "Like the void that contains all possibilities"
                ],
                "connection": [
                    "Like the space in which all experiences arise and dissolve",
                    "Like breath that connects inner and outer worlds"
                ]
            },
            
            "seeker": {
                "transformation": [
                    "Like a traveler discovering that the journey itself is the destination",
                    "Like a question that evolves into deeper questioning"
                ],
                "challenge": [
                    "Like a key that only reveals its purpose when the right door appears",
                    "Like a puzzle piece finding its perfect place in the larger picture"
                ],
                "connection": [
                    "Like a song recognizing itself in other melodies",
                    "Like a star discovering its place in the constellation"
                ]
            }
        }
    
    async def _calculate_reflection_confidence(self, layers: Dict[str, str], 
                                             context: ReflectionContext, 
                                             depth_requested: str) -> float:
        """Calculate dynamic confidence score based on therapeutic accuracy indicators"""
        
        base_confidence = 0.75
        confidence_factors = []
        
        # Layer completeness factor
        expected_layers = self.depth_levels.get(depth_requested, [])
        completed_layers = len([layer for layer in expected_layers if layer.value in layers])
        layer_completeness = completed_layers / len(expected_layers) if expected_layers else 0
        confidence_factors.append(layer_completeness * 0.3)  # 30% weight
        
        # Context richness factor
        context_richness = 0.0
        if getattr(context, 'growth_level', None):
            context_richness += 0.4
        if getattr(context, 'soul_archetype', None):
            context_richness += 0.6
        confidence_factors.append(context_richness * 0.2)  # 20% weight
        
        # AI vs fallback factor
        ai_factor = 0.9 if self.ai_enabled else 0.7
        confidence_factors.append(ai_factor * 0.1)  # 10% weight
        
        # Layer quality factor (based on length and content)
        avg_layer_length = sum(len(content) for content in layers.values()) / len(layers) if layers else 0
        length_factor = min(avg_layer_length / 100, 1.0)  # Normalize to 0-1
        confidence_factors.append(length_factor * 0.2)  # 20% weight
        
        # Safety appropriateness factor
        user_data = {
            'growth_level': getattr(context, 'growth_level', 5.0),
            'current_challenges': getattr(context, 'current_challenges', [])
        }
        depth_level, readiness_score = await self.determine_user_readiness(user_data)
        depth_numeric = self._calculate_depth_level(depth_requested)
        
        safety_factor = 0.8  # Default
        if depth_numeric <= readiness_score:
            safety_factor = 0.9  # Appropriate depth
        else:
            safety_factor = 0.6  # Depth exceeds readiness
        
        confidence_factors.append(safety_factor * 0.2)  # 20% weight
        
        # Calculate weighted confidence
        total_confidence = base_confidence + sum(confidence_factors)
        
        # Ensure confidence stays within bounds
        final_confidence = max(0.5, min(0.95, total_confidence))
        
        return final_confidence
    
    async def _validate_therapeutic_safety(self, insight: str, layers: Dict[str, str], 
                                         context: ReflectionContext) -> Dict[str, Any]:
        """Validate therapeutic safety and identify potential concerns"""
        
        safety_concerns = []
        
        # Crisis indicators in insight
        crisis_keywords = [
            'suicide', 'kill myself', 'end it all', 'not worth living', 'hopeless',
            'self-harm', 'cutting', 'hurting myself', 'want to die', 'giving up'
        ]
        
        insight_lower = insight.lower()
        for keyword in crisis_keywords:
            if keyword in insight_lower:
                safety_concerns.append(f"Crisis indicator: {keyword}")
        
        # Check for harmful guidance in layers
        harmful_patterns = [
            'your fault', 'you deserve this', 'you should be ashamed',
            'you\'re broken', 'you can\'t change', 'give up'
        ]
        
        for layer_name, layer_content in layers.items():
            layer_lower = layer_content.lower()
            for pattern in harmful_patterns:
                if pattern in layer_lower:
                    safety_concerns.append(f"Harmful content in {layer_name}: {pattern}")
        
        return {
            'safe': len(safety_concerns) == 0,
            'concerns': safety_concerns,
            'reason': '; '.join(safety_concerns) if safety_concerns else None
        }
    
    async def _assess_clinical_framework_adherence(self, layers: Dict[str, str], 
                                                 context: ReflectionContext) -> float:
        """Assess adherence to clinical therapeutic frameworks"""
        
        adherence_score = 0.5  # Base score
        
        # Check for trauma-informed language
        positive_indicators = ['safe', 'choice', 'strength', 'resilience', 'growth', 'healing']
        harmful_indicators = ['fault', 'blame', 'broken', 'hopeless', 'weakness']
        
        for layer_content in layers.values():
            layer_lower = layer_content.lower()
            
            # Positive therapeutic language
            positive_count = sum(1 for indicator in positive_indicators if indicator in layer_lower)
            adherence_score += positive_count * 0.1
            
            # Harmful language reduces score
            harmful_count = sum(1 for indicator in harmful_indicators if indicator in layer_lower)
            adherence_score -= harmful_count * 0.2
        
        # Ensure score stays in valid range
        return max(0.0, min(1.0, adherence_score))
    
    async def _apply_safety_modifications(self, layers: Dict[str, str], 
                                        safety_check: Dict[str, Any]) -> Dict[str, str]:
        """Apply safety modifications when concerns detected"""
        
        modified_layers = layers.copy()
        
        # If crisis detected, add safety messaging
        has_crisis = any('crisis indicator' in concern.lower() for concern in safety_check['concerns'])
        
        if has_crisis:
            safety_note = " Please remember that professional support is available if you're struggling."
            for layer_name in modified_layers:
                if safety_note not in modified_layers[layer_name]:
                    modified_layers[layer_name] += safety_note
        
        # Replace harmful phrases
        harmful_replacements = {
            'your fault': 'not your responsibility',
            'broken': 'healing',
            'hopeless': 'supported'
        }
        
        for layer_name, layer_content in modified_layers.items():
            for harmful, safe in harmful_replacements.items():
                modified_layers[layer_name] = layer_content.replace(harmful, safe)
        
        return modified_layers